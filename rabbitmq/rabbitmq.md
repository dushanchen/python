### 1. 原理
基于erlang语言开发、实现AMQP协议

producer -> broker(exchange -> queue) -> consumer

broker:
  - virtual host
    - queue
    - exchange 

exchange -(routing key)> queue

virtual host：
    用户资源隔离
channel：
    每个客户端连接可以有多个channel，以节省服务器资源，避免建立太多的tcp连接而造成资源浪费
exhange：
    name 名称
    type 类型
    
queue：
    存储消息，可以设置长度、消息超时时间
    Durability： Durable/ Transient (持久化、临时性)

业务端口5672，UI端口15672

#### 四种主要的交换机
Direct 精确匹配
    定向，由routing key 匹配队列
Fanout 广播
    广播，发送给绑定的所有队列
topic 
    通配符，发送给符合routing pattern的队列，路由模式
headers
    规则：不依赖路由键，而是根据消息头（Headers）中的键值对进行匹配。较少使用。
交换机只具备转发能力，不能存储消息。如果没有绑定队列，那么消息会丢失。

#### 七种用法
helloworld：
    生产者直接向一个队列发送消息，一个消费者从队列获取消息
working queue：
    默认交换机，一个队列，多个消费者竞争队列中的消息（默认是轮询所有消费者），用于任务分发和负载均衡
pub/sub：
    fanout 交换机，广播到多个队列，监听同一个队列的消费者也是竞争关系
routing：
    direct 交换机， 交换机绑定队列，并指定routing key
topics：
    topic 交换机， routing key 使用通配符，#匹配零个或多个词、*匹配一个词
RPC：
    同步调用
headers：

#### 其他功能
死信队列
    1）拒绝消费，消息被消费端拒绝消费，并不放入原队列
    2）队列溢出。队首溢出的消息进入死信队列
    3）消息超时
    处理方式：
    丢弃、入库、监听（消费端监听死信队列做处理）
    需要创建死信交换机并指定给正常的交换机，创建死信路由键、死信队列绑定死信交换机

事务消息：
    在客户端批量提交消息，具有原子性，可回滚。这是客户端的功能，并不是rabbitmq本身的功能
    生产者将信道设置为事务模式，如果所有消息都成功发送，则提交事务，否则可以回滚
    在spring框架下用Transaction注解

惰性队列：
    允许存储大量的消息，在消息堆积时持久化到硬盘，需要被消费时再从硬盘加载。

优先队列：
    消息设置优先级。在消息发送后置处理器，指定消息优先级，数字越大越优先，优先级高的消息先进入队列

集群：
    haproxy 实现负载均衡

    仲裁队列：
        type: Quorum 
    
    流式队列：
        stream

Federation插件：
    实现像集群一样的跨服务器消息互通功能，在某些场景是不方便组集群的，比如跨数据中心、网络隔离、跨公有云私有云、跨部门应用
    集群要求所有节点网络低延迟、运行相同版本的软件、节点间开发特定防火墙
    联邦插件通过AMQP协议实现broker之间的通信
    1）联邦交换机
    目标：实现将一个上游交换机收到的消息，自动异步复制到一个或多个下游交换机
    步骤：在下游broker上定义一个upstream链接，并指向上游broker的交换机；
         在下游创建一个交换机，并与upstream绑定。这个交换机称为联邦交换机
         消息自动异步的从上游交换机传递到所有下游交换机
         下游交换机收到消息后，照常转发到绑定的队列
    2）联邦队列
    目标：实现负载均衡，本地broker较为空闲时，自动从上游预取一部分消息缓存到本地进行处理。这样也可以保证在上游消费者故障时，消息可以在下游被消费
    流程：
         在下游 Broker 上定义一个 Upstream 链接，指向上游 Broker 的 Queue。
         在下游 Broker 上创建一个 Federated Queue，并将其与这个 Upstream 链接绑定。
         当本地的 Federated Queue 需要消息时（例如，有本地消费者连接但队列为空），它会从上游队列中拉取消息。它也可以主动从上游队列“借”一些消息过来，以平衡负载。
shovel 插件：



### 2. 应用场景
应用解藕、流量削峰、异步任务

延迟队列：
    比如订单限时1个小时完成支付
    1）消息过期 + 死信队列
    2）安装插件 rabbitmq-delayed-message-exchange 最多延迟两天 
        交换机参数： type: x-delayed-message  arguments: x-delayed-type: direct





### 3. 有哪些坑
消息丢失
    1）消息没有发送到队列上
        发布确认机制（Publisher Confirm）
            spring 配置：
                publisher-confirm-type: CORRELATED 交换机确认
                publisher-returns: true 队列确认
            创建配置类实现故障回调接口，broker通过该回调告知生产者消息是否接受成功，生产者根据情况进行重发或其他操作
            也可以同步确认。
        使用备份交换机
    2）消息队列宕机，消息没有持久化
        消息持久化到硬盘：
            配置队列持久化：durable=true
            配置消息持久化：delivery_mode=2
        或者配置集群并创建镜像队列，将主节点的队列消息复制到镜像队列，在主节点服务宕机后依然保证镜像队列节点服务可用
    3）消费端出现问题，导致消息没有消费成功
        消费者设置autoAck=false
        消费端消费成功返回ack信息，失败返回nack信息（可决定是否将消息重新放回队列，可判断是否是重复投递的又消费失败，可以不再放回队列）
        消费端还可以直接拒绝消费消息，如果不重新放入队列，那么会进入私信队列。
        如果rabbitmq检测到消费过程中消费者断连，会将消息重新放入队列，交给其他消费者
        deliveryTag：64位整数，交付标签机制，消息的唯一标识 

消息超时
    给消息设定过期时间，过期后删除，进入死信队列



### 4. 大厂主流方案
rabbitmq在obs中的使用：
1. 异步处理
用户上传图片、视频类文件，obs后台需要生成缩略图、鉴黄等操作，这些耗时操作，都是放入消息队列处理
2. 复制备份
当用户需要将数据备份，比如从一个桶拷贝到另一个桶，可能会有大量的数据，此种场景使用rabbitmq来做削峰处理，以免影响正常的上传下载业务

### 5. 面试题
1）为什么使用消息队列
    系统解耦，使用消息队列作为系统中间件，可以减少系统改动
    异步任务，多个耗时任务可以进入消息队列异步处理，不需要用户请求一直等待，提升用户体验
    流量消峰，在秒杀等业务情况下，瞬时流量增加，系统可以承受不住压力而奔溃，将消息放入消息队列以作缓冲，后台按能力处理，避免奔溃
2）主流消息中间件的优缺点
    主流消息队列： 
    kafka：分布式日志采集、大数据采集， 吞吐量非常大、性能非常好、技术生态完整； 功能单一
    Rabbitmq：企业内部调用； 消息可靠性高、功能全面； 吞吐量较低、消息积压时会影响性能
    rocketmq： 应用场景较多、比如金融； 高吞吐、高性能、高可用，高级功能非常全； 技术生态相对没那么完整
3）rabbitmq的工作原理
    connection、channel、exchange、queue、routing key、
4）rabbitmq的队列中消息数量是否有限制，单个消息大小可达多大
    默认：数量无限制。单个消息理论上无限制，建议控制在几十kb
    主动限制：可通过 x-max-length 和 x-max-length-bytes（消息总字节数） 在队列级别进行控制。
    全局保护：通过配置内存和磁盘警报机制，在服务器级别防止资源耗尽

5）rabbigmq的工作模式有哪些
    前述7种
6）rabbitmq的消息基于什么传输
    RabbitMQ 的消息传输基于 AMQP 协议，并通过 信道（Channel） 机制在 TCP 连接上实现多路复用。
7）rabbitmq怎么确保消息被消费
    前述消息丢失的处理办法
8）rabbitmq支持事务消息吗
    事务消息是让本地业务逻辑和消息发送成为一个原子操作，保证数据一致性。
    rabbitmq本身不支持事务消息；
    rabbitmq的事务模式是保证多个消息都成功投递，生产者将信道设置为事务模式，如果所有消息都成功发送，则提交事务，否则可以回滚
    发布者确认机制只能保证消息成功投递，不能保证与本地事务的原子性
    
    rabbitmq 需要通过额外的编程来实现事务消息：
        事务性发件箱：执行本地事务时，把要发送的消息存入同一个数据库的某个业务表中，再通过一个独立的业务进程来处理这些消息，采用发布者确认机制，确保这些消息发送，发送成功后删除原表中的消息记录。
    rocketmq 如何实现事务消息：
        事务回查机制：如果预备消息发送到了rocketmq，但是没有收到生产者的提交或者回滚请求，rocketmq会定期扫描这些未知的消息，并向生产者发起回调查询，生产者端程序要提供一个回调接口，用于查询本地事务的执行结果，并回应给rocketmq是否提交、回滚上述的未知消息。
9）rabbitmq消息持久化的条件
    队列必须设置持久化（durable=true，如果不持久化，重启后队列会消失）
    消息必须配置持久化（delivery_mode=2，默认是1，非持久化）
    交换机配置为持久化（默认交换机是默认持久化的，新建的交换机要配置持久化）
10）rabbitmq惰性队列怎么使用
    惰性队列为了解决大量消息积压的场景，消息积压会增加内存压力、导致服务不可用
    原理：
        消息直接存磁盘、内存中保留索引、消费时从磁盘加载到内存
    优点：
        内存压力小、性能稳定、重启恢复快
    缺点：
        消费延迟增大、系统磁盘压力增大（适合用ssd）
    场景：
        预计有大量消息的场景且时延要求低，比如异步日志处理、数据同步任务
11）rabbitmq如何处理消息堆积的情况
    使用惰性队列
    配置增加队列最大长度和最大容量
    使用死信队列保存被丢弃和被拒绝消费的消息
    监控：
        使用managementUI 监控、使用prometheus和grafana监控
    扩容：
        增加消费者数量、提升消费者的消费速度
12）如何保证消息队列的高可用
    rabbitmq采用的是镜像队列
    原理：
        在集群模式下，一个队列对应有主节点和镜像队列节点，主节点将队列的消息和状态同步给镜像队列节点
        生产者、消费者，只与主节点通信；
        主节点收到消息后，同步给镜像节点，当所有节点都收到消息后，主节点才确认，这样保证数据的强一致性。
        主节点故障后，最老的镜像节点升级为主节点，客户端会感知并与主节点断连，然后自动重连新的主节点
    优点：
        服务不中断、消息不丢失
    缺点：
        性能开销大、资源消耗大
13）如何保证消息的顺序性
    单个队列、direct交换机、单个消费者
14）如何实现延时队列
    利用 TTL + 死信交换机
    为消息或队列设置一个生存时间。超过 TTL 后，消息会“死亡”，它会被重新发布到指定的死信交换机
15）如何使消息优先被消费
    使用rabbitmq优先队列
    声明队列时指定最大优先级x-max-priority，发送消息时指定消息的优先级（默认时为0），不能超过最大优先级，队列会根据优先级从大到小的顺序进行消费。
    消息进入队列时且队列中不为空，会触发排序。消费者准备获取消息时，会触发排序
16）如何保证消息的幂等性
    重复消息的原因：
        rabbitmq收到消息后由于网络波动等原因，没有及时回复ack信息，生产者就又重复了消息
        消费者在处理消息后，连接断开或应用奔溃导致没有回复ack信息，rabbitmq认为消费失败会将消息重新投递
    解决办法：
        从消费端入手，判断消息是否被消费过；可以从数据库层面判断，也可以使用redis的setNx的原子性来判断消息是否被消费过
17）消息为什么会成为死信，如何处理
    队列溢出、被拒绝消费、消息超时
18）无法路由的消息去了那里
    1.rabbitmq 默认丢弃无法路由的消息，永久消失。
    2.配置mandatory参数为true，则在无法路由时返回给生产者，生产者自定义回调来接收退还的消息。
    3.使用备用交换机，投递到一个队列进行保存