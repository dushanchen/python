### 1. 原理
基于erlang语言开发、实现AMQP协议

producer -> broker(exchange -> queue) -> consumer

broker:
  - virtual host
    - queue
    - exchange 

exchange -(routing key)> queue

virtual host：
    用户资源隔离
channel：
    每个客户端连接可以有多个channel，以节省服务器资源，避免建立太多的tcp连接而造成资源浪费
exhange：
    name 名称
    type 类型
    
queue：
    存储消息，可以设置长度、消息超时时间
    Durability： Durable/ Transient (持久化、临时性)

业务端口5672，UI端口15672

#### 四种主要的交换机
Direct 精确匹配
    定向，由routing key 匹配队列
Fanout 广播
    广播，发送给绑定的所有队列
topic 
    通配符，发送给符合routing pattern的队列，路由模式
headers

交换机只具备转发能力，不能存储消息。如果没有绑定队列，那么消息会丢失。

#### 七种用法
helloworld：

working queue：
    默认交换机，一个队列，多个消费者竞争队列中的消息
pub/sub：
    fanout 交换机，广播到多个队列，监听同一个队列的消费者也是竞争关系
routing：
    direct 交换机， 交换机绑定队列，并指定routing key
topics：
    topic 交换机， routing key 使用通配符，#匹配零个或多个词、*匹配一个词
RPC：
    同步调用
Publisher Confirms：
    发送端消息确认

#### 其他功能
死信队列
    1）拒绝消费，消息被消费端拒绝消费，并不放入原队列
    2）队列溢出。队首溢出的消息进入死信队列
    3）消息超时
    处理方式：
    丢弃、入库、监听（消费端监听死信队列做处理）
    需要创建死信交换机并指定给正常的交换机，创建死信路由键、死信队列绑定死信交换机

事务消息：
    在客户端批量提交消息，具有原子性，可回滚。这是客户端的功能，并不是rabbitmq本身的功能
    在spring框架下用Transaction注解

惰性队列：
    允许存储大量的消息，在消息堆积时持久化到硬盘，需要被消费时再从硬盘加载。

优先队列：
    消息设置优先级。在消息发送后置处理器，指定消息优先级，数字越大越优先，优先级高的消息先进入队列

集群：
    haproxy 实现负载均衡

    仲裁队列：
        type: Quorum 
    
    流式队列：
        stream

Federation插件：
    实现像集群一样的跨服务器消息互通功能，在某些场景是不方便组集群的，比如跨数据中心、网络隔离、跨公有云私有云、跨部门应用
    集群要求所有节点网络低延迟、运行相同版本的软件、节点间开发特定防火墙
    联邦插件通过AMQP协议实现broker之间的通信
    1）联邦交换机
    目标：实现将一个上游交换机收到的消息，自动异步复制到一个或多个下游交换机
    步骤：在下游broker上定义一个upstream链接，并指向上游broker的交换机；
         在下游创建一个交换机，并与upstream绑定。这个交换机称为联邦交换机
         消息自动异步的从上游交换机传递到所有下游交换机
         下游交换机收到消息后，照常转发到绑定的队列
    2）联邦队列
    目标：实现负载均衡，本地broker较为空闲时，自动从上游预取一部分消息缓存到本地进行处理。这样也可以保证在上游消费者故障时，消息可以在下游被消费
    流程：
         在下游 Broker 上定义一个 Upstream 链接，指向上游 Broker 的 Queue。
         在下游 Broker 上创建一个 Federated Queue，并将其与这个 Upstream 链接绑定。
         当本地的 Federated Queue 需要消息时（例如，有本地消费者连接但队列为空），它会从上游队列中拉取消息。它也可以主动从上游队列“借”一些消息过来，以平衡负载。
shovel 插件：



### 2. 应用场景
应用解藕、流量削峰、异步任务

延迟队列：
    比如订单限时1个小时完成支付
    1）消息过期 + 死信队列
    2）安装插件 rabbitmq-delayed-message-exchange 最多延迟两天 
        交换机参数： type: x-delayed-message  arguments: x-delayed-type: direct





### 3. 有哪些坑
消息丢失
    1）消息没有发送到队列上
        生产端进行确认
            spring 配置：
                publisher-confirm-type: CORRELATED 交换机确认
                publisher-returns: true 队列确认
            创建配置类实现故障回调接口
        使用备份交换机
    2）消息队列宕机，消息没有持久化
        消息持久化到硬盘
    3）消费端出现问题，导致消息没有消费成功
        消费端消费成功返回ack信息，失败返回nack信息（可决定是否将消息重新放回队列，可判断是否uk j是重复投递的又消费失败，可以不再放回队列）
        deliveryTag：64位整数，交付标签机制，消息的唯一标识 

消息超时
    给消息设定过期时间，过期后删除，进入死信队列



### 4. 大厂主流方案

主流消息队列： 
kafka：分布式日志采集、大数据采集， 吞吐量非常大、性能非常好、技术生态完整； 功能单一
Rabbitmq：企业内部调用； 消息可靠性高、功能全面； 吞吐量较低、消息积压时会影响性能
rocketmq： 应用场景较多、比如金融； 高吞吐、高性能、高可用，高级功能非常全； 技术生态相对没那么完整

rabbitmq在obs中的使用：
1. 异步处理
用户上传图片、视频类文件，obs后台需要生成缩略图、鉴黄等操作，这些耗时操作，都是放入消息队列处理
2. 复制备份
当用户需要将数据备份，比如从一个桶拷贝到另一个桶，可能会有大量的数据，此种场景使用rabbitmq来做削峰处理，以免影响正常的上传下载业务


### 5. 面试题
1）为什么使用消息队列
2）主流消息中间件的优缺点
3）rabbitmq的工作原理
rabbitmq的队列中消息数量是否有限制，单个消息大小可达多大
rabbigmq的工作模式有哪些
rabbitmq的消息基于什么传输
rabbitmq怎么确保消息被消费
rabbitmq支持事务消息吗
rabbitmq消息持久化的条件
rabbitmq惰性队列怎么使用
rabbitmq如何处理消息堆积的情况
4）消息为什么会丢失，如何保证消息的可靠性传输
5）如何保证消息队列的高可用
6）如何保证消息的顺序性
如何实现延时队列
如何使消息优先被消费
如何保证消息的幂等性
消息为什么会成为死信，如何处理
如何避免消息重复投递或重复消费
无法路由的消息去了那里